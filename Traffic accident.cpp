#include <unsupported/Eigen/MatrixFunctions>
#include <cstdio>
#include <iostream>
#include <iomanip>
#include <cmath>
#include <complex>
#include <cstdlib>
#include <cstdio>
#include<ctime>
#include <vector>
#include <math.h>
#include <stdlib.h>
#include <fstream>
#include <windows.h>
#include <sql.h>
#include <sqlext.h>
#include <sqltypes.h>
#include<time.h>


using namespace Eigen;
using namespace std;

int main(){

	ofstream oFile;

    oFile.open("市區道路交通事故延續時間預測.csv", ios::out | ios::trunc);


//--------------------------------參數項(X矩陣)----------------------------------------//

//-------------------------行為參數項種類; 列為不同筆參數-----------------------------//
MatrixXd X(255,5);
X<<
1,	10,	48.76,	0.8,	9,
1,	11,	46.21,	1.44,	12,
1,	17,	29.77,	1.02,	8,
1,	12,	45.84,	1.5,	10,
1,	5,	48.1,	1.1,	24,
1,	10,	30.56,	0.77,	15,
1,	7,	35.61,	0.77,	3,
1,	10,	30.33,	0.77,	15,
1,	18,	42.69,	0.74,	7,
1,	10,	42.18,	0.87,	8,
1,	9,	40.77,	1,	6,
1,	14,	33.1,	0.77,	25,
1,	10,	29.7,	0.74,	13,
1,	9,	27.48,	0.75,	21,
1,	8,	50.56,	0.87,	8,
1,	12,	45.55,	1.5,	14,
1,	12,	48.38,	0.7,	8,
1,	8,	18.68,	0.74,	20,
1,	11,	25.89,	0.57,	41,
1,	13,	28.45,	0.57,	24,
1,	8,	55.85,	1.39,	11,
1,	5,	47.58,	0.58,	4,
1,	10,	48.92,	1.02,	13,
1,	12,	31.41,	0.77,	28,
1,	15,	27.59,	0.57,	10,
1,	9,	34.43,	0.74,	2,
1,	8,	44.25,	0.74,	10,
1,	32,	21.53,	0.42,	24,
1,	6,	46.4,	1.15,	9,
1,	9,	47.15,	1.5,	15,
1,	34,	27,	1.39,	9,
1,	9,	47.51,	0.74,	10,
1,	10,	46.09,	1.49,	5,
1,	9,	42.01,	1.49,	19,
1,	12,	46.41,	7.28,	13,
1,	10,	23.71,	0.52,	13,
1,	10,	44.12,	0.77,	1,
1,	12,	48.22,	0.68,	15,
1,	16,	29.27,	0.77,	6,
1,	16,	45.28,	0.74,	17,
1,	13,	31.86,	0.77,	17,
1,	10,	41.88,	1.02,	10,
1,	10,	28.96,	0.77,	5,
1,	9,	36.94,	0.58,	20,
1,	10,	43.31,	1.5,	7,
1,	10,	46.13,	1.15,	6,
1,	12,	46.22,	1.14,	10,
1,	7,	44.2,	1.02,	5,
1,	10,	29.77,	0.85,	19,
1,	7,	41.36,	1.24,	9,
1,	10,	30.61,	0.77,	18,
1,	14,	42.14,	1.02,	6,
1,	14,	36.46,	0.77,	7,
1,	7,	28.56,	0.74,	23,
1,	10,	38.28,	0.74,	17,
1,	6,	47.27,	0.74,	11,
1,	11,	33.35,	0.55,	26,
1,	13,	30.63,	0.77,	20,
1,	13,	47.16,	1.15,	3,
1,	7,	26.89,	0.77,	21,
1,	6,	42.95,	0.74,	6,
1,	10,	44.64,	1.5,	3,
1,	6,	45.05,	0.74,	14,
1,	4,	30.17,	0.61,	33,
1,	8,	38.57,	0.62,	33,
1,	5,	44.06,	1.14,	14,
1,	12,	29.94,	0.77,	6,
1,	11,	33.43,	0.77,	25,
1,	7,	32.55,	0.74,	17,
1,	6,	39.66,	0.47,	12,
1,	10,	47.22,	1.08,	30,
1,	6,	34.08,	0.77,	17,
1,	7,	42.67,	1.39,	9,
1,	7,	45.86,	1,	6,
1,	10,	48.47,	1.39,	12,
1,	35,	26.34,	0.46,	6,
1,	48,	25.68,	0.74,	13,
1,	7,	43.72,	1.15,	11,
1,	7,	49.19,	0.74,	19,
1,	20,	38.33,	0.74,	6,
1,	6,	43.51,	1.02,	22,
1,	8,	31.36,	0.8,	9,
1,	8,	46.99,	0.74,	9,
1,	16,	47.08,	0.74,	5,
1,	8,	27.56,	0.9,	7,
1,	8,	27.56,	0.77,	16,
1,	13,	29.15,	0.77,	8,
1,	10,	49.19,	0.74,	5,
1,	18,	31.03,	0.77,	15,
1,	10,	44.38,	1.21,	16,
1,	7,	40.95,	0.74,	22,
1,	7,	31.9,	0.77,	36,
1,	7,	27.87,	0.57,	29,
1,	8,	28.59,	0.75,	7,
1,	11,	45.24,	0.74,	5,
1,	4,	44.99,	0.58,	13,
1,	10,	47.21,	1.06,	11,
1,	14,	45.99,	0.74,	5,
1,	8,	38.43,	0.61,	5,
1,	12,	30.5,	0.77,	18,
1,	8,	28.81,	0.42,	18,
1,	10,	44.87,	1.15,	10,
1,	17,	42.92,	0.48,	8,
1,	7,	29.39,	0.77,	8,
1,	12,	43.38,	1.4,	17,
1,	9,	28.43,	0.77,	14,
1,	11,	30.1,	0.7,	9,
1,	13,	38.06,	0.77,	2,
1,	20,	15.93,	0.43,	9,
1,	11,	46.35,	1.14,	14,
1,	11,	30.42,	0.77,	14,
1,	6,	34.6,	0.74,	24,
1,	22,	37.75,	1.02,	16,
1,	18,	25.89,	0.77,	17,
1,	8,	34.57,	0.74,	12,
1,	11,	41.23,	1,	24,
1,	11,	48.81,	0.74,	4,
1,	11,	27.28,	0.77,	16,
1,	5,	33.17,	0.57,	7,
1,	13,	31.77,	0.99,	14,
1,	5,	30.48,	0.77,	3,
1,	8,	42.39,	0.74,	16,
1,	9,	34.49,	0.77,	6,
1,	9,	37.24,	0.87,	5,
1,	33,	27.45,	0.74,	21,
1,	11,	37.99,	1,	3,
1,	13,	16.94,	0.74,	4,
1,	14,	24.05,	0.77,	14,
1,	5,	38.63,	1.5,	14,
1,	18,	36.15,	0.74,	7,
1,	9,	30.28,	0.77,	8,
1,	11,	38.81,	0.43,	4,
1,	7,	39.83,	1.02,	11,
1,	8,	30.9,	0.77,	4,
1,	7,	41.01,	0.74,	5,
1,	13,	42.13,	1.02,	11,
1,	9,	46.18,	1.5,	15,
1,	7,	39.42,	0.74,	15,
1,	6,	37.41,	0.74,	12,
1,	12,	43.23,	1.02,	4,
1,	10,	39.21,	0.74,	12,
1,	9,	44.07,	1.5,	14,
1,	12,	42.5,	1.02,	16,
1,	7,	30.5,	0.77,	10,
1,	19,	22.25,	0.77,	4,
1,	10,	47.2,	1.14,	18,
1,	12,	27.23,	0.77,	17,
1,	12,	31.62,	0.43,	23,
1,	15,	39.81,	0.74,	6,
1,	12,	41.62,	1.14,	2,
1,	16,	42.92,	1,	5,
1,	12,	35.85,	0.43,	13,
1,	11,	23.58,	0.77,	13,
1,	7,	35.31,	0.74,	13,
1,	16,	43.21,	1.02,	13,
1,	11,	33.28,	0.77,	12,
1,	12,	28.15,	0.77,	4,
1,	13,	41.59,	1.02,	13,
1,	8,	41.23,	1.5,	2,
1,	10,	30.74,	0.77,	22,
1,	12,	26.79,	0.43,	27,
1,	15,	32.56,	0.77,	15,
1,	11,	30.64,	0.74,	24,
1,	9,	36.25,	0.43,	7,
1,	17,	24.2,	0.77,	20,
1,	13,	32.11,	0.77,	13,
1,	7,	43.84,	1.02,	8,
1,	22,	26.37,	0.74,	12,
1,	10,	30.95,	0.43,	38,
1,	20,	42.29,	1.14,	8,
1,	13,	28.46,	0.43,	15,
1,	16,	41.43,	1.38,	10,
1,	7,	34.63,	0.43,	6,
1,	10,	31.25,	0.77,	13,
1,	15,	29.46,	0.57,	26,
1,	37,	19.8,	0.43,	8,
1,	9,	31.15,	0.43,	38,
1,	9,	33.47,	0.77,	14,
1,	9,	29.53,	0.57,	9,
1,	26,	27.99,	0.77,	18,
1,	10,	32.57,	0.57,	10,
1,	8,	28.45,	0.77,	7,
1,	10,	39.81,	0.74,	2,
1,	20,	32.32,	0.57,	4,
1,	12,	39.28,	1.38,	7,
1,	19,	40.44,	1.02,	9,
1,	10,	33.33,	0.43,	5,
1,	7,	34.98,	0.43,	12,
1,	19,	29.88,	0.57,	8,
1,	24,	44.41,	0.74,	2,
1,	8,	31.56,	0.77,	14,
1,	9,	42.51,	0.74,	19,
1,	9,	23.44,	0.77,	21,
1,	15,	27.1,	1.5,	13,
1,	10,	38.74,	1.14,	4,
1,	20,	30.74,	0.77,	8,
1,	11,	28.83,	0.74,	3,
1,	12,	28.98,	1.14,	37,
1,	13,	23.97,	0.84,	10,
1,	9,	34.24,	1,	31,
1,	9,	37.96,	1.02,	16,
1,	8,	29.86,	0.77,	26,
1,	7,	28.34,	0.77,	15,
1,	13,	34.7,	0.74,	29,
1,	11,	37.37,	1.02,	25,
1,	12,	27.84,	0.74,	16,
1,	12,	31.1,	0.57,	24,
1,	13,	33.83,	0.74,	13,
1,	14,	34.19,	0.77,	28,
1,	14,	25.61,	0.43,	21,
1,	18,	32.51,	0.77,	16,
1,	11,	40.08,	1.38,	25,
1,	9,	30.01,	0.43,	16,
1,	8,	29.74,	0.43,	22,
1,	8,	40.21,	1,	23,
1,	14,	23.64,	0.57,	21,
1,	18,	26.79,	0.74,	26,
1,	10,	23.73,	0.74,	11,
1,	12,	29.18,	0.77,	16,
1,	11,	30.34,	0.77,	10,
1,	17,	36.44,	1.02,	5,
1,	10,	27.91,	0.77,	9,
1,	27,	19.67,	0.43,	30,
1,	11,	30.22,	0.77,	4,
1,	16,	20.46,	0.77,	36,
1,	8,	30.96,	0.57,	15,
1,	12,	31.15,	0.77,	15,
1,	10,	31.03,	0.77,	23,
1,	7,	40.13,	1,	26,
1,	7,	35.75,	0.74,	28,
1,	9,	45.89,	1.02,	14,
1,	12,	32.02,	0.77,	3,
1,	6,	18.68,	0.43,	24,
1,	22,	23.05,	0.77,	4,
1,	10,	44.15,	1.5,	16,
1,	10,	24.7,	0.43,	40,
1,	13,	30.89,	0.77,	9,
1,	12,	45.65,	1,	30,
1,	11,	47.68,	1.38,	17,
1,	9,	28.98,	0.43,	12,
1,	12,	39.74,	1,	25,
1,	13,	28.76,	0.77,	25,
1,	9,	31.88,	0.74,	28,
1,	9,	34.95,	0.43,	9,
1,	8,	36.83,	0.74,	16,
1,	8,	36.83,	0.74,	30,
1,	13,	23.76,	0.57,	37,
1,	9,	30.28,	0.77,	7,
1,	11,	35.79,	0.43,	27,
1,	7,	44.82,	1.02,	8,
1,	7,	32.89,	0.77,	4,
1,	8,	28.87,	0.43,	26,
1,	5,	45,	1.14,	16,
1,	19,	40.77,	0.74,	22,
1,	10,	35.53,	0.57,	8;




int mm=X.row(0).size();  //組間數量
int nn=X.col(0).size(); // 回歸數量
MatrixXd Theta_1(mm,1);             //解析回歸係數解
MatrixXd Theta_2 (mm,1);            //梯度下降回歸係數解

srand( time(NULL) );

double S1;
double S2;

double PROD_Multi;
double Cossim;

double R_square;
double SST;
double SSE;
double SSR;
double Y_Nor_avg;
//-------------------梯度下降迴歸係數初始化; 範圍設定[-1,1]---------------------------//

for(int j=0;j<Theta_2.row(0).size();++j){

for(int i=0;i<Theta_2.col(0).size();++i){

Theta_2 (i,j)=(double) rand() /(RAND_MAX+1 );
}

}

//------------------------------------------------------------------------------------//

double  f;
double  F;
//------------------------------------------------------------------------------------//

MatrixXd X_avg(1,mm);    // 每一項參數平均值
MatrixXd u(1,mm);        // 每一項參數最大值與最小值差
MatrixXd X_Nor(nn,mm);    // 輸入X矩陣正規化結果

//------------------------------自變數X矩陣正規化----------------------------------------//
for(int i=0;i<X.row(0).size();++i){
 X_avg(0,i)=(X.col(i)).sum()/X.col(0).size();
 u(0,i)=X.col(i).maxCoeff()-X.col(i).minCoeff();

}

for(int i=0;i<X.col(0).size();++i){
for(int j=0;j<X.row(0).size();++j){

X_Nor(i,j)=(X(i,j)-X_avg(0,j))/u(0,j);
X_Nor(i,0)=1;

}
}
//cout<<u<<endl;
//cout<<X_Nor<<endl;
//------------------------------------------------------------------------------------//
//----------------------------延遲時間正規化(單位:s)----------------------------------//
MatrixXd Y(nn,1);
Y<<
10,
11,
17,
12,
5,
10,
7,
10,
18,
10,
9,
14,
10,
9,
8,
12,
12,
8,
11,
13,
8,
5,
10,
12,
15,
9,
8,
32,
6,
9,
34,
9,
10,
9,
12,
10,
10,
12,
16,
16,
13,
10,
10,
9,
10,
10,
12,
7,
10,
7,
10,
14,
14,
7,
10,
6,
11,
13,
13,
7,
6,
10,
6,
4,
8,
5,
12,
11,
7,
6,
10,
6,
7,
7,
10,
35,
48,
7,
7,
20,
6,
8,
8,
16,
8,
8,
13,
10,
18,
10,
7,
7,
7,
8,
11,
4,
10,
14,
8,
12,
8,
10,
17,
7,
12,
9,
11,
13,
20,
11,
11,
6,
22,
18,
8,
11,
11,
11,
5,
13,
5,
8,
9,
9,
33,
11,
13,
14,
5,
18,
9,
11,
7,
8,
7,
13,
9,
7,
6,
12,
10,
9,
12,
7,
19,
10,
12,
12,
15,
12,
16,
12,
11,
7,
16,
11,
12,
13,
8,
10,
12,
15,
11,
9,
17,
13,
7,
22,
10,
20,
13,
16,
7,
10,
15,
37,
9,
9,
9,
26,
10,
8,
10,
20,
12,
19,
10,
7,
19,
24,
8,
9,
9,
15,
10,
20,
11,
12,
13,
9,
9,
8,
7,
13,
11,
12,
12,
13,
14,
14,
18,
11,
9,
8,
8,
14,
18,
10,
12,
11,
17,
10,
27,
11,
16,
8,
12,
10,
7,
7,
9,
12,
6,
22,
10,
10,
13,
12,
11,
9,
12,
13,
9,
9,
8,
8,
13,
9,
11,
7,
7,
8,
5,
19,
10;


MatrixXd Y_avg(nn,1);
MatrixXd Y_Nor(nn,1);

for(int i=0;i<Y.col(0).size();++i){
for(int j=0;j<Y.row(0).size();++j){

Y_avg(i,j)=Y.sum()/Y.size();

Y_Nor(i,j)=(Y(i,j)-Y_avg(0,j))/(Y.maxCoeff()-Y.minCoeff());


}
}
//------------------------------------------------------------------------------------//
//----------------------------------回歸解析解----------------------------------------//

Theta_1=(X_Nor.transpose()*X_Nor).inverse()*X_Nor.transpose()*Y_Nor;


//----------------------------------梯度下降法計算-------------------------------------//
MatrixXd J_Th(1,1);
MatrixXd MSE(1,1);
 
//double s=pow(2*(X.row(0)).size(),-1);
MatrixXd Grad_J(nn,1);
double Lr=0.1;                 // 學習率
double ep=60000;               //疊代數
MatrixXd J_Th_Lambda(1,1);
double apha=0.1;
double J[60000];
MatrixXd PROD(1,1);           //
MatrixXd Y_R(nn,1);
MatrixXd Y_Inv_nor(nn,1);
MatrixXd  MAPE(nn,1);
MatrixXd  MAPE_ratio(nn,1);
double MAPE_sum;
//---------------------------------------"疊代開始"----------------------------------------------------------// 
  for(int k=0;k<ep;++k)

    {

//J_Th= pow(2*(X_Nor.col(0)).size(),-1)*(((X_Nor*Theta_2).array() )-(Y_Nor.array()) ).square();

J_Th= pow(2*(X_Nor.col(0)).size(),-1)*((X_Nor*Theta_2-Y_Nor ).transpose()) *(X_Nor*Theta_2-Y_Nor) + apha*pow(2*(X_Nor.col(0)).size(),-1)*Theta_2.transpose() * Theta_2 ;
//J_Th= pow(2*(X_Nor.col(0)).size(),-1)*((X_Nor*Theta_2-Y_Nor ).transpose()) *(X_Nor*Theta_2-Y_Nor) + apha*Theta_2.transpose() * Theta_2 ;
MSE= pow(2*(X_Nor.col(0)).size(),-1)*((X_Nor*Theta_2-Y_Nor ).transpose()) *(X_Nor*Theta_2-Y_Nor);


J[k]=J_Th.sum();

Grad_J= 2*pow(2*(X_Nor.col(0)).size(),-1)*(X_Nor*Theta_2-Y_Nor).transpose() * X_Nor;

//Grad_J= 2*pow(2*(X_Nor.col(0)).size(),-1)*(X_Nor*Theta_2-Y_Nor).transpose() * X_Nor;
Theta_2=(1-Lr*apha*pow((X_Nor.col(0)).size(),-1))*Theta_2-Lr*Grad_J.transpose();
//Theta_2=Theta_2-Lr*Grad_J.transpose();

//-------------------------收斂條件:當下疊帶值與前一次疊帶值差值 eps<10^-8---------------------------//
	if(abs(J[k] -J[k-1]) <pow(10,-8) )
		{
            break;

        }

//-------------殘差平方和SSE(實際值Vs預測值)---------------//
  SSE=2*(X_Nor.col(0)).size()* MSE(0,0);//Σ(yi-y_hat_i)^2


//-------------總平方和SST(實際值Vs平均值)---------------//

MatrixXd SS_T(nn,1);

Y_Nor_avg=Y_Nor.sum()/Y_Nor.size();

for(int i=0;i<Y.col(0).size();++i){
for(int j=0;j<Y.row(0).size();++j){

SS_T(i,j)=pow((Y_Nor(i,j)-Y_Nor_avg),2);//Σ(yi-y_avg)^2

}
}
SST=SS_T.sum();




R_square=1- SSE/SST;

Y_R=X_Nor*Theta_2;

MatrixXd SS_R(nn,1);

//-------------總平方和SSR(實際結果Vs平均值)---------------//

for(int i=0;i<Y.col(0).size();++i){
for(int j=0;j<Y.row(0).size();++j){

SS_R(i,j)=pow((Y_R(i,j)-Y_Nor_avg),2);//Σ(y_hat_i-y_avg)^2


}
}

 SSR=SS_R.sum();
f=(SSR)/(SSE);

F=f*(nn-mm-1)/mm;


//-----------------------複相關分析-------------------------// 






oFile <<"epoch="<< k  << "  ,  " <<" MSE= "<< "  ,  "<<J[k] << "  ,  " << R_square<< endl;


}





for(int i=0;i<Y.col(0).size();++i){
for(int j=0;j<Y.row(0).size();++j){

Y_Inv_nor(i,j)=Y_R(i,j)*(Y.maxCoeff()-Y.minCoeff())+Y_avg(0,j);

}
}

for(int iii=0;iii<Y.col(0).size();++iii){
for(int jjj=0;jjj<Y.row(0).size();++jjj){

MAPE_ratio(iii,jjj)=(Y(iii,jjj)-Y_Inv_nor(iii,jjj))/Y(iii,jjj); 

}
}


MatrixXd COV1(nn,1);
MatrixXd COV2(nn,1);

PROD=(Y_Inv_nor).transpose()*Y;

PROD_Multi=PROD(0,0);



COV1=(Y_Inv_nor).array().square();
COV2=(Y).array().square();

S1=COV1.sum();
S2=COV2.sum();


Cossim=PROD_Multi/sqrt(S1*S2);


oFile <<Y_Inv_nor<<Y<<endl;

//cout<<endl;
//cout<<X<<endl;
//cout<<"X矩陣正規化"<<endl;
//cout<<endl;
//cout<<X_Nor<<endl;
//cout<<endl;
//cout<<" 房價 (Y)  "   <<endl;
//cout<<endl;
//cout<< Y <<endl;
//cout<<endl;
//cout<<"模擬後房價結果"<<endl;
//cout<<endl;
//cout<<Y_Inv_nor<<endl;
//cout<<endl;
cout<<"---------------------------------------------------"<<endl;
cout<<"|                     迴歸係數                     |"<<endl;
cout<<"---------------------------------------------------"<<endl;
cout<<endl;
for(int i=0;i<Theta_2.col(0).size();++i){
for(int j=0;j<Theta_2.row(0).size();++j){
cout<<"Beta_"<<i<<" = "<<Theta_2(i,j)<<endl;
cout<<endl;
}
}

cout<<"----------------------------------------------------"<<endl;
cout<<"|                 R平方值與擬合程度                 |"<<endl;
cout<<"----------------------------------------------------"<<endl;

cout<<"SSE="<<SSE<<endl;
cout<<endl;

cout<<"SST="<<SST<<endl;
cout<<endl;

cout<<"R_sqare=1-(SSE/SST)"<<endl;
cout<<endl;

cout<<"R_square="<<R_square<<endl;
cout<<endl;
if(R_square<0.5)

cout<<"欠擬合(underfitting)"<<endl;

else if (R_square>0.5&&R_square<0.9)

cout<<"擬合"<<endl;

else if (R_square>0.9)

cout<<"過擬合(overfitting)"<<endl;

cout<<"F-value"<<endl;

cout<<F<<endl;

cout<<"預測與實際準確度 "<<endl;  
cout<<Cossim<<endl;  

cout<<"MAPE值"<<endl; 

cout<< abs(MAPE_ratio.sum())/nn<<endl;           






}



